# Project 3
**Group Members:**
1. Yash Goel, UFID - 51939756

**Outline:**

We have implemented the chord protocol in Erlang using the Actor Model. We used object access service to implement the protocol. We defined a finger table to store our hash value and defined certain check conditions to check for termination.


## Usage

1. cd the project folder
2. Start erl shell and compile main, generate_chord_network, generate_node, stabilize_chord_network and utility_functions using c(file_name).
3. Run main.erl and give the desired parameters (Number of Nodes, Messages, Failure Nodes).
4. Run generate_chord_network.erl
5. Run generate_node.erl
6. Run stabilize_chord_network.erl
7. Run utility_functions.erl
8. Ignore the warning anf follow the inputs generated by code to start implementing the chord protocol.

## Implementation Details

To run the program, execute main.erl by following the above directions, fill the desired values and start the network.

**main.erl**

This code takes general inputs from the user, builds the desired network by calling the other module and spawns the processes accordingly. 

**generate_chord_network.erl**

This code implements the chord network by initializing a ring and then adding nodes, every time a new node is added t stabilizes the ring and checks for a node's task completion as well as overall network's task completion and display the average hops and time required to reach there. 

**generate_node.erl**

This code handles the cast and call functions, it generates the processes and updates the finger table after extracting the successor and notifying the predecessor to update the current state and current node list. This then gets to the nearest node and gets its successor. Finally, it checks if a particular node has completed its task or not. 

**stabilize_chord_network.erl**

This code stabilizes our chord network and fixes the finger table at every new entry. It gets the successor and predecessor and updates their states and sends the message to the nodes.  

**utility_functions.erl**

This code contains general functions that are utilized in all other files multiple times for faster access. 

## Assignment Details

**1. Work Unit:**
1. We varied the number of nodes as a parameter to create 2^m nodes (M) where m = ceiling of log2n.
2. We select n nodes from the given 1 to M nodes to generate the network and the reaming nodes i.e M-n nodes are stored with their successor for future use.
3. We then select a random nodes from our generated network. This random node is searched by all the other memeber nodes in the chord ring, these members need to search this node exactly the number of times as specified by number of messages parameter.
4. We then create a finger table for every generated node and stabilize our chord ring to calculate the average number of hops it took for one particular node to earch for another node.

**2. What is working?**
1. We implemented the chord network based on the algorithm/methodology discussed in the research paper.
2. Initially there was a challenge while genrating distinct node ID as a result of the hashing algorithm specified in the problem statement. We resolved it by using m bit reduction and incorporated a random number approach to resolve the issue.
3. The largest network was with 2000 nodes with 10 messages each, the average number of hops to reach the target node was in the range of [2.5 - 4.8] for number of nodes ranging from 100-2000. The average value is around 3.37 hops that is it takes 3.67 hops for a node to sarch for any other node in our chord ring.

**3. Observations:**

| Number of Nodes | Average Hops |
| --------------- |:------------:|
| 100             | 2.2          |
| 500             | 3.6          |
| 1000            | 3.9          |
| 2000            | 4.7          |


**4. Result:**

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ![100](https://user-images.githubusercontent.com/113138630/197431131-4d5930c1-0169-4e48-b0d8-55c7c9cfc927.png)
![100r](https://user-images.githubusercontent.com/113138630/197431158-faa9e99c-312f-4fa6-b99b-33dbc00c6d14.jpeg)
<div align="center"> *Fig.1 Result for 100 nodes for 10 messages with 2 failure nodes.* </div>\


&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ![1000](https://user-images.githubusercontent.com/113138630/197431908-b99b969c-8139-4fca-9ebc-1503bd6bbd0d.png)

![WhatsApp Image 2022-10-23 at 8 41 23 PM (1)](https://user-images.githubusercontent.com/113138630/197431984-20df77da-704d-43bf-8d0f-41ba37b1c1d7.jpeg)
<div align="center"> *Fig.2 Result for 1000 nodes for 10 messages with 5 failure nodes.* </div>\
